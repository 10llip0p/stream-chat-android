# Users

TODO intro

## Connecting a User

To perform actions with the SDK, you have to connect a user first. You can use three different types of users: regular, guest, and anonymous users.

### Regular users

Stream uses JWT (JSON Web Tokens) to authenticate regular chat users. These tokens have to be generated by your server and then passed into the client side SDK calls to log in the user.

```kotlin
val user = User(
    id = "bender",
    extraData = mutableMapOf(
        "name" to "Bender",
        "image" to "https://bit.ly/321RmWb",
    ),
)

// You can set up a user token in two ways:

// 1. Setup the current user with a JWT token
val token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiZmFuY3ktbW9kZS0wIn0.rSnrWOv8EbsiYzJlvVwqwCgATZ1Magj_fZl-bZyCHKI"
client.connectUser(user, token).enqueue { result ->
    if (result.isSuccess) {
        // Logged in
        val user: User = result.data().user
        val connectionId: String = result.data().connectionId
    } else {
        // Handle result.error()
    }
}

// 2. Setup the current user with a TokenProvider
val tokenProvider = object : TokenProvider {
    // Make a request to your backend to generate a valid token for the user
    override fun loadToken(): String = yourTokenService.getToken(user)
}
client.connectUser(user, tokenProvider).enqueue { /* ... */ }
```

### Guest Users

Guest sessions can be created client-side and do not require any server-side authentication. Support and livestreams are common use cases for guest users because often you want a visitor to be able to use chat on your application without (or before) they have a regular user account.

Guest users are not available to application using multi-tenancy (teams).

> Unlike anonymous users, guest users are counted towards your MAU usage.

Guest users have a limited set of permissions. You can create a guest user session by using `connectGuestUser` instead of `connectUser`.

```kotlin
client.connectGuestUser(userId = "bender", username = "Bender").enqueue { /*... */ }
```

### Anonymous Users

If a user is not logged in, you can call the `connectAnonymousUser` method. While you’re anonymous, you can’t do much, but for the `livestream` channel type, you’re still allowed to read the chat conversation.

```kotlin
client.connectAnonymousUser().enqueue { /*... */ }
```

When you connect to chat using anonymously you receive a special user back with the following data:

```xml
{
	"id": "!anon",
	"role": "anonymous",
	"roles": [],
	"created_at": "0001-01-01T00:00:00Z",
	"updated_at": "0001-01-01T00:00:00Z",
	"last_active": "2020-11-02T18:36:01.125136Z",
	"banned": false,
	"online": true,
	"invisible": false,
	"devices": [],
	"mutes": [],
	"channel_mutes": [],
	"unread_count": 0,
	"total_unread_count": 0,
	"unread_channels": 0,
	"language": ""
}
```
> Anonymous users are not counted toward your MAU number and only have an impact on the number of concurrent connected clients.


## Querying Users

### Regular users

The `ChatClient::queryUsers` method allows you to search for users and see if they are online/offline. The example below shows how you can retrieve the details for 3 users in one API call:

```kotlin
// Search for users with id "john", "jack", or "jessie" 
val request = QueryUsersRequest( 
    filter = Filters.`in`("id", listOf("john", "jack", "jessie")), 
    offset = 0, 
    limit = 3, 
) 
 
client.queryUsers(request).enqueue { result -> 
    if (result.isSuccess) { 
        val users: List<User> = result.data() 
    } else { 
        // Handle result.error() 
    } 
}
```

### Banned users
Another option is to query for banned users. This can be done with the following code snippet:

```kotlin
val request = QueryUsersRequest( 
    filter = Filters.eq("banned", true), 
    offset = 0, 
    limit = 10, 
) 
 
client.queryUsers(request).enqueue { /* ... */ }
```

Please be aware that this query will return users banned across the entire app, not at a channel level.

You can filter and sort on the custom fields you've set for your user, the user id, and when the user was last active.

The options for the `queryUsers` method are presence, limit, and offset. If presence is `true` this makes sure you receive the `user.presence.changed` event when a user goes online or offline.

### Users by search term
You can autocomplete the results of your user query by username and/or ID.

If you want to return all users whose username includes 'ro', you could do so with the following:
```kotlin
val request = QueryUsersRequest( 
    filter = Filters.autocomplete("name", "ro"), 
    offset = 0, 
    limit = 10, 
) 
client.queryUsers(request).enqueue { /* ... */ }
```

This would return an array of any matching users, such as:

```kotlin
[ 
    { 
        "id": "userID", 
        "name": "Curiosity Rover" 
    }, 
    { 
        "id": "userID2", 
        "name": "Roxy" 
    }, 
    { 
        "id": "userID3", 
        "name": "Roxanne" 
    } 
]
```


## User presence

User presence allows you to show when a user was last active and if they are online right now. Whenever you read a user the data will look like this:

```xml
{
    id: 'unique_user_id',
    online: true,
    status: 'Eating a veggie burger...',
    last_active: '2019-01-07T13:17:42.375Z'
}
```
> The online field indicates if the user is online. The status field stores text indicating the current user status.

### Marking a User Invisible

To mark a user invisible simply set the `invisible` property to `true`. You can also set a custom status message at the same time:

```kotlin
val user = User(
    id = "user-id",
    invisible = true,
)
client.connectUser(user, "user-token").enqueue { result ->
    if (result.isSuccess) {
        val user: ConnectionData = result.data()
    } else {
        // Handle result.error()
    }
}
```
> When invisible is set to true, the current user will appear as offline to other users.

> **NOTE**: User's invisible status can be only set while calling `connectUser` method

### Listening to User Presence Changes

These 3 endpoints allow you to watch user presence:

```kotlin
// You need to be watching some channels/queries to be able to get presence events.
// Here are three different ways of doing that:

// 1. Watch a single channel with presence = true set
val watchRequest = WatchChannelRequest().apply {
    data["members"] = listOf("john", "jack")
    presence = true
}
channelClient.watch(watchRequest).enqueue { result ->
    if (result.isSuccess) {
        val channel: Channel = result.data()
    } else {
        // Handle result.error()
    }
}

// 2. Query some channels with presence = true set
val channelsRequest = QueryChannelsRequest(
    filter = Filters.and(
        Filters.eq("type", "messaging"),
        Filters.`in`("members", listOf("john", "jack")),
    ),
    offset = 0,
    limit = 10,
).apply {
    presence = true
}
client.queryChannels(channelsRequest).enqueue { result ->
    if (result.isSuccess) {
        val channels: List<Channel> = result.data()
    } else {
        // Handle result.error()
    }
}

// 3. Query some users with presence = true set
val usersQuery = QueryUsersRequest(
    filter = Filters.`in`("id", listOf("john", "jack")),
    offset = 0,
    limit = 2,
    presence = true,
)
client.queryUsers(usersQuery).enqueue { result ->
    if (result.isSuccess) {
        val users: List<User> = result.data()
    } else {
        // Handle result.error()
    }
}

// Finally, subscribe to presence to events
client.subscribeFor<UserPresenceChangedEvent> { event ->
    // Handle change
}
```

Users' online status change can be handled via event delegation by subscribing to the `user.presence.changed` event the same you do for any other event.

